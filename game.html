<!DOCTYPE html>
<html>
<head>
<link href="https://fonts.googleapis.com/css?family=Space+Mono:00" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #eee;
}
body{
    background-color: #ddd;
    font-family: Space Mono;
}
</style>
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

<!-- page title -->
<title>Cool</title>


</head>
<body onload="startGame()">

<!-- <div class="jumbotron text-center">
  <h1>Escape</h1> 
</div> -->

<div style="text-align:center;">
    <canvas id="myCanvas" width="400" height="600px"></canvas> 
<!-- style="bposition:absolute;
    width:100%;
    height:100%; -->

</div>

<script>
// http://www.w3schools.com/graphics/game_canvas.asp
var myGamePiece;
var myObstacles = [];
var myScore;
var power = 1;
var ww = document.getElementById("myCanvas").width;
var hh= document.getElementById("myCanvas").height;
var pause = false;

var xx = ww/2
var yy = hh - 90;

var max_obstacles_per_row = 20;
var obstacle_size = ww / 20;
var number_obstacles = 3;

var dist_rows = 80
var row_speed = 4.0;
var score = 0;
var speed_increase_coeff = 0.04;
var player_color = "#333"
var obstacle_color = "#555"

var player_size = 2 / 3 * obstacle_size

var current_canvas = document.getElementById("myCanvas");

var touch = false;
var rightTouch = true;

function startGame() {
    myGameArea.start();
    myGamePiece = new player(player_size, player_size, player_color, xx, yy);
    xx = ww/2;
    yy = hh - 90;
    testManager = new rowManager(max_obstacles_per_row - 5, row_speed , dist_rows );
    testManager.createRow();
    row_speed = 4.0;
    score = 0;
}

function pause()
{

}

var myGameArea = {
    canvas : document.getElementById("myCanvas"),
    start : function() {
        this.canvas = document.getElementById("myCanvas");
        ww = this.canvas.width ;
        hh = this.canvas.height ;
        this.context = this.canvas.getContext("2d");
        //document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('keydown', function (e) {
            myGameArea.key = e.keyCode;
            if (myGameArea.key && myGameArea.key == 80) { 
             pause = !pause;
            }
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.key = false;
        })
        window.addEventListener('touchmove', function (e) {
            var rect = current_canvas.getBoundingClientRect();
            if ( e.touches[0].screenX - rect.left < ww/2)
            {
                rightTouch = false;
            }
            else
            {
                rightTouch = true;
            }
        })
        window.addEventListener('touchstart', function (e) {
            touch = true;
            var rect = current_canvas.getBoundingClientRect();
            if ( e.touches[0].screenX - rect.left < ww/2)
            {
                rightTouch = false;
            }
            else
            {
                rightTouch = true;
            }
        })
        window.addEventListener('touchend', function (e) {
            touch = false;
        })

    }, 
    clear : function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function player(width, height, color, x, y) {
    this.coeff_bounce = 0.1
    this.friction = 0.1
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y; 
    this.speedX = 0;
    this.speedY = 0;
    this.a ={ x: this.x - width / 2, y: this.y + height / 2 };
    this.b = { x : this.x, y : this.y - height / 2 };
    this.c = { x: this.x+width/2, y: this.y + height / 2 };
    this.getLeft= function(){return this.a}
    this.getRight= function(){return this.c}
    this.getTop = function(){return this.b}
    this.update = function(){
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        // tri
        ctx.beginPath();
        ctx.moveTo( this.a.x, this.a.y );
        ctx.lineTo(this.b.x, this.b.y);
        ctx.lineTo(this.c.x , this.c.y );
        ctx.fill();
        
    }
    this.newPos = function(canvas){
        var tmp = this.x + this.speedX;
        if (tmp - this.width/2 > 0 && tmp + this.width / 2 < canvas.width )
        {
            this.x = tmp;
        }
        else
        {
            this.speedX = - this.coeff_bounce * this.speedX;
        }
        this.speedX *= (1-this.friction);

        this.a ={ x: this.x - width / 2, y: this.y + height / 2 };
        this.b = { x : this.x, y : this.y - height / 2 };
        this.c = { x: this.x+width/2, y: this.y + height / 2 };
            
    }
}

function obstacle(x,y,www,color){
    this.x = x;
    this.y = y;
    this.w = www;
    this.color = color;
    this.draw = function(ctx)
    {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.w/2, this.y - this.w/2,this.w,this.w);
        
    }
   this.updatePos = function(y){
        this.y = y;
    }
    this.isPointIntersect = function(point){
        return ( point.x >= this.x - this.w/2 && point.x <= this.x+this.w/2 && point.y>=this.y- this.w/2&&point.y<=this.y+this.w/2 )
    }
   this.intersect = function (player){
        // assuming player < obstacle
        return ( this.isPointIntersect(player.getLeft() ) || this.isPointIntersect( player.getRight() ) || this.isPointIntersect( player.getTop() ) );
    }
}

function m_row(n,h,www,color){
    this.obstacles = []
    this.h = h;
    for (var i = 0; i<n;i++){
        xx = obstacle_size/2 + Math.floor( Math.random() * max_obstacles_per_row) * obstacle_size; //
        this.obstacles.push( new obstacle( xx,h,www,color )  );
    }

    this.draw = function(ctx){
        this.obstacles.forEach( function (obs){
            obs.draw(ctx);
        });
    }
    this.setSpeed = function(velocity)
    {
        this.v = velocity;
    }
    this.updatePos = function()
    {
        this.h += this.v;
        var hhh = this.h;
        this.obstacles.forEach( function (obs){
            obs.updatePos( hhh );
        });
    }
   this.intersect = function(player){
        var intersect = false;
        this.obstacles.forEach( function (obs){
            if (obs.intersect(player)){ intersect = true ;}
        });
        return intersect

    }
}

function rowManager( n, speed , distance ){
    this.n = n;
    this.speed = speed;
    this.distance = distance;
    this.childs = [];
    this.createRow = function(){
        this.childs.unshift( new m_row(number_obstacles, - obstacle_size / 2 ,obstacle_size - 2, obstacle_color) );
        this.childs[0].setSpeed(row_speed);
        
    }
    this.setSpeed = function(v){
        this.speed = v;
        this.childs.forEach( function (row){
            row.setSpeed(v);
        });
    }
    this.increaseSpeed = function(){
        this.setSpeed(this.speed + speed_increase_coeff)
    }
    this.updatePos = function(){
        this.childs.forEach( function (row){
            row.updatePos();
        });
    }
    this.draw = function(ctx){
       this.childs.forEach( function (row){
            row.draw( ctx );
        }); 
    }
    this.updateRows = function(){
        first_row = this.childs[0];
        if (first_row.h + obstacle_size/2 > dist_rows )
        {
            this.createRow();
        }

        lastRow = this.childs[this.childs.length - 1];
        if ( lastRow.h - obstacle_size / 2 > hh )
        {
            this.childs.pop();
            score +=1;
            this.increaseSpeed();
        }
    }
    this.isPointIntersect = function(point, row){
        return ( row.h - obstacle_size / 2 < point.y  &&  row.h + obstacle_size / 2 > point.y)
    }
    this.intersectRow = function(player, row){
        intersect = false;
        if ( this.isPointIntersect(player.getLeft() ,row ) || this.isPointIntersect( player.getRight(), row ) || this.isPointIntersect( player.getTop(), row ) ){
                console.log(row);
                if (row.intersect(player) ){ intersect = true; }
        }
        return intersect;
    }
    this.intersect = function(player){
        x = false;
        tmp = this;
        this.childs.forEach( function (row){
            if ( tmp.intersectRow(player,row)){x = true;}
        });
        return x;
    }

    this.drawScore = function(ctx){
        ctx.font="20px Space Mono";
        ctx.fillStyle="white";
        ctx.fillText("score: " + score ,50,50);

    }
}

function updateGameArea() {
    myGameArea.clear();
    testManager.updateRows();
    
    if (!pause){
        if (myGameArea.key && myGameArea.key == 37) {myGamePiece.speedX += -power; }
        if (myGameArea.key && myGameArea.key == 39) {myGamePiece.speedX += power; }
        if (myGameArea.key && myGameArea.key == 38) {myGamePiece.speedY += -power; }
        if (myGameArea.key && myGameArea.key == 40) {myGamePiece.speedY += power; }
        if (touch){
            if (rightTouch){
                myGamePiece.speedX += power;
            }
            else
            {
                myGamePiece.speedX += -power;
            }
        }

        myGamePiece.newPos(myGameArea.canvas); 
        myGamePiece.update();
        testManager.updatePos();
    }
    else
    {
        myGamePiece.update();
        ctx = myGameArea.context;
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)"
        ctx.fillRect(0, 0, myGameArea.canvas.width, myGameArea.canvas.height);
    }
    testManager.draw(myGameArea.context);
    testManager.drawScore(myGameArea.context);
    if (testManager.intersect(myGamePiece)) { pause = true }
    
}

</script>
</body>
</html>

